[TOC]

## 二叉树

递归：**写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节**

**写树相关的算法，简单说就是，先搞清楚当前 `root` 节点「该做什么」以及「什么时候做」，然后根据函数定义递归调用子节点**，递归调用会让孩子节点做相同的事情。

所谓「该做什么」就是让你想清楚写什么代码能够实现题目想要的效果，所谓「什么时候做」，就是让你思考这段代码到底应该写在**前序、中序还是后序遍历**的代码位置上。

```c++
/* 二叉树遍历框架 */
void traverse(TreeNode *root) 
{
    if (root == nullptr)
    {
        return;
    }
    // 前序遍历
    traverse(root->left)
    // 中序遍历
    traverse(root->right)
    // 后序遍历
}
```

## 图

图的遍历和二叉树有类似。下面以矩形网格遍历举例子，当前节点要干啥，然后遍历的它的子节点（上下左右）。

网格 dfs 框架

```java
void dfs(int[][] grid, int r, int c) {
    // 判断 base case
    if (!inArea(grid, r, c)) {
        return;
    }
    // 如果这个格子不是岛屿，直接返回
    if (grid[r][c] != 1) {
        return;
    }
    grid[r][c] = 2; // 将格子标记为「已遍历过」
    
    // 访问上、下、左、右四个相邻结点
    dfs(grid, r - 1, c);
    dfs(grid, r + 1, c);
    dfs(grid, r, c - 1);
    dfs(grid, r, c + 1);
}

// 判断坐标 (r, c) 是否在网格中
boolean inArea(int[][] grid, int r, int c) {
    return 0 <= r && r < grid.length 
        	&& 0 <= c && c < grid[0].length;
}

```

## 前缀和

前缀和思想

https://leetcode-cn.com/problems/subarray-sum-equals-k/

求一个**静态数组**某个区间内所有数的和 的时候，我们便可以使用前缀和，有效提高运行效率。

| index |  0   |  1   |  2   |  3   |  4   |  5   |
| :---- | :--: | :--: | :--: | :--: | :--: | :--: |
| nums  |  2   |  1   |  4   |  6   |  4   |  8   |
| pre   |  2   |  3   |  7   |  13  |  17  |  25  |

如上数组，我们可以看到

pre[i] 为 0 ~ i 的和

所以 pre[5] - pre[2] = 18 = nums[3] + nums[4] + nums[5]

所以 pre[i] - pre[j - 1] = nums[j] + ... + nums[i]

经过简单移项，我们可以得出 pre[i] = pre[j] + k，这样子对于前缀和的问题就可以着手解决了。

## 二分法

二分模板

```cpp
class Solution {
public:
    /**
     * @param nums: An integer array sorted in ascending order
     * @param target: An integer
     * @return: An integer
     */
    int findPosition(vector<int> &nums, int target) {
        if (nums.size() == 0)
        {
            return -1;
        }

        int start = 0;
        int end = nums.size() - 1;
        while (start + 1 < end) /* 如果一直找不到目标值, 最后会剩下两个 */
        {
            int mid = (start + end) / 2; /* 防止溢出这样子写更好 int mid = start + (end - start) / 2; */
            if (nums[mid] == target)
            {
                return mid;
            }
            else if (nums[mid] < target)
            {
                start = mid; /* 也可以写做start = mid + 1, 直接相等可以偷懒 */
            }
            else
            {
                end = mid;
            }
        }
        if (nums[start] == target) /* 判断剩下两个值是否符合条件 */
        {
            return start;
        }
        if (nums[end] == target)
        {
            return end;
        }

        return -1;
    }
};
```

